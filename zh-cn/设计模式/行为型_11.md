# 行为型设计模式

>用于描述程序在运行时的复杂流程控制,即描述多个类或者对象之间怎样像话剖哦共同完成单个对象无法单独完成的任务,涉及算法和对象的职责分配

---





**类行为: 继承机制来在类间分派行为** 



## 1. 模板方法(Template Method)

> 定义一个操作中的算法骨架,将算法的一些步骤延迟到子类中,使得子类可以不改变算法结构的情况下重定义改算法的某些特定步骤.

### 1.应用场景

1. 算法的整体步骤很固定,但其中个别部分易变,(提供子类的实现)
2. 多个子类存在公共行为时,可以提取出来到一个公共父类中,避免代码重复
3. 当需要控制子类的拓展时,模板方法只在特定点调用钩子操作,这样就只允许在这些点进行拓展

> Spring : 模板和回调的结合, JDBC的抽象和对Hibernate的集成
>
> Spring : 集中的方式来处理资源的获取和释放

### 2.优点

1. 封装了不可变得部分,拓展可变得部分.便于子类继续拓展.
2. 在父类中提取了公共的部分代码,便于**代码复用** 
3. 部分方法是由子类实现的,子类可以通过拓展的方式增加相应的功能,符合**开闭原则** 

### 3.缺点

1. 对不同的实现都需要一个子类,导致类的个数增加,系统更加庞大,设计更加抽象,间接地增加了系统的实现的复杂度
2. 父类中的抽象方法由子类实现,子类执行的结构会影响父类的结果,这导致一种反向控制结构,提高了代码阅读的难度
3. 继承的缺点,如果父类添加新的抽象方法,则所有的子类都要修改一遍



## 2. 解释器(interpreter)

### 1.应用场景



### 2.优点



### 3.缺点



**对象行为: 采用组合或聚合在对象间分配行为 (合成复用原则) 具有更大的灵活性**

## 3. 策略(Strategy)

> 定义一系列算法,并将每个算法封装起来,使他们可以相互替换,且算法的变化不会影响使用算法的用户.

### 1.应用场景

1. 一个系统需要动态地在几种算法中选择一种时,可以将每个算法封装到策略类中
2. 一个类定义了多种行为,并且 这些行为在这个类的操作中以多个条件语句的形式出现,可将每个**条件分支** 移入他们各自的策略类中以代替这些条件语句
3. 系统中算法彼此完全独立,且要求对客户隐藏具体算法的实现细节时.
4. 系统要求使用算法的客户不应该知道其操作的数据时,可使用策略模式来**隐藏**与算法相关的数据结构
5. 多个类只区别在**表现行为** 不同,可以使用策略模式,在运行时动态选择具体要执行的行为



> java SE : 容器布局管理,
>
> Spring : 资源访问的Resource接口 需要的实现类

### 2.优点

1. 多重条件语句不易维护, 而使用策略模式可以避免使用多重条件语句,if...else switch..case语句
2. 提供了一系列可供重用的算法族,恰当使用继承可以吧算法族的公共代码转义到父类里面,从而**避免重复代码** 
3. 可以提供相同行为的不同实现,客户可以根据不同的时间或空间要求选择不同的
4. 对**开闭原则** 的完美支持,可以在不修改源代码的情况下,灵活增加新算法
5. 把算法的使用放到环境类中,而算法的实现移到策略类中,实现了二者的分离

### 3.缺点

1. client必须理解所有策略算法的区别,以便选择
2. 有很多的策略类,增加维护难度



## 4. 命令(Command)

### 1.应用场景



### 2.优点



### 3.缺点



## 5. 职责链(Chain of Responsibility)

### 1.应用场景



### 2.优点



### 3.缺点



## 6. 观察者(Observer)

> 多个对象间存在**一对多** 的依赖关系, 当一个对象的状态发生改变时,所有依赖他的对象都得到通知并被**自动** 更新. 发布-订阅模式

### 1.应用场景

> java: Observer Observable 接口 setChanged(); notifyObservers();
>
> spring: 事件驱动模型 listener的实现
>
> 组件是事件源->目标对象, 事件处理程序类的对象是具体观察者对象

### 2.优点

1. 降低了目标与观察者之间的耦合关系,两者之间是抽象耦合关系.符合**依赖倒置** 原则
2. 目标与观察者之间建立了一套触发机制

### 3.缺点

1. 目标与观察者之间的依赖关系没有完全解除,而且有可能出现循环引用
2. 当观察者对象很多时,通知的发布会花费很多时间,影响程序的**效率** 



## 7. 中介者(Mediator)

### 1.应用场景



### 2.优点



### 3.缺点



## 8. 迭代器(lterator)

### 1.应用场景



### 2.优点



### 3.缺点



## 9. 访问者(Visitor)

> 将作用于某种数据结构中的各元素的操作分离出来封装成独立的类, 使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作, 为每个元素提供多种访问方式.
>
> 对数据的操作与数据结构进行分离.
>
> 对集合中的不同类型数据(类型数量稳定) 进行多种操作时, 使用访问者模式

### 1.应用场景

1. 对象结构相对稳定, 但其C座算法经常变化的程序
2. 对象结构中的对象需要提供多种不同且不相关的操作, 而且要避免让这些操作的变化影响对象的结构.
3. 对象结构包含很多类型的对象, 希望这些对象实施一些依赖于具体类型的操作
4.  迭代器  组合模式

> 

### 2.优点

1. 拓展性,能够在不修改对象结构中元素的情况下, 为对象结构中的元素添加新的功能.
2. 复用性, 可以通过访问者来定义整个对象结构通用功能, 从而提高系统的**复用** 程度. 
3. 灵活性好, 将数据结构与作用于结构上得操作解耦, 使得操作集合可相对的自由演化而不影响系统的数据结构
4. **单一职责原则** 把相关的行为封装的一起, 构成一个访问者, 使每一个访问者的功能比较单一.

### 3.缺点

1. 增加新的元素很困难.在访问者模式中, 没增加一个新的元素, 都要在每一个具体访问者类中增加相应的操作, `违背开闭原则`
2. 破坏封装. 具体的元素对访问者公布细节, 这破坏了对象封装性.
3. `违反依赖倒置原则` ,依赖了具体类, 而没有



## 10. 备忘录(Memento)

### 1.应用场景



### 2.优点

1. 

### 3.缺点

1. 



## 11. 状态(State)

### 1.应用场景



### 2.优点



### 3.缺点

