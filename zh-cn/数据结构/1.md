## 回溯
> 和DFS类似, 暴力穷举, 回溯在遍历[树枝], DFS是在遍历[节点]

解决一个回溯问题实际就是一个决策树的遍历过程, 站在一个回溯节点上, 只要思考3个问题
1. path: 已经做出的选择
2. choiceList: 当前可以做的选择
3. endCond: 当到达底层的结束条件

```python
def backtrack(path,choiceList):
    if true:
        result.add(path)
        return
    for choice in choiceList:
        # 核心: 递归前做选择, 递归后撤销选择
        doChoice
        backtrack(path,choiceList)
        backChoice
```


[46.全排列](https://leetcode.cn/problems/permutations/)

```go
var Res [][]int
func permute(nums []int) [][]int {
	Res = [][]int{}
	choiceList := make([]int,0)
	used := make([]bool, 10, 10)
	permute_(nums,choiceList,used)
	return Res
}

func permute_(path, choiceList []int, used [] bool) {
	// endCond
	if len(path) == len(choiceList){
		p:=make([]int,len(choiceList))
		copy(p,choiceList)
		Res = append(Res,p)
		return
	}

	for i:=0; i<len(path); i++{
		if(used[i])  {
			continue
		}

		// do
		choiceList = append(choiceList,path[i])
		used[i] = true
		//recursion
		permute_(path,choiceList,used)

		//backdo
		choiceList = choiceList[:len(choiceList)-1]
		used[i] = false
	}
}
```


