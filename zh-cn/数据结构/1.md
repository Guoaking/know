## 工具箱



## 回溯
> 和DFS类似, 暴力穷举, 回溯在遍历[树枝], DFS是在遍历[节点]

解决一个回溯问题实际就是一个决策树的遍历过程, 站在一个回溯节点上, 只要思考3个问题
1. path: 已经做出的选择
2. choiceList: 当前可以做的选择
3. endCond: 当到达底层的结束条件

```python
def backtrack(path,choiceList):
    if true:
        result.add(path)
        return
    for choice in choiceList:
        # 核心: 递归前做选择, 递归后撤销选择
        doChoice
        backtrack(path,choiceList)
        backChoice
```


[46.全排列](https://leetcode.cn/problems/permutations/)
[51.N皇后](https://leetcode.cn/problems/n-queens/)
[剑指offer 83.没有重复元素的集合](https://leetcode.cn/problems/VvJkup/)
```go
var Res [][]int
func permute(nums []int) [][]int {
	Res = [][]int{}
	choiceList := make([]int,0)
	used := make([]bool, 10, 10)
	permute_(nums,choiceList,used)
	return Res
}

func permute_(path, choiceList []int, used [] bool) {
	// endCond
	if len(path) == len(choiceList){
		p:=make([]int,len(choiceList))
		copy(p,choiceList)
		Res = append(Res,p)
		return
	}

	for i:=0; i<len(path); i++{
		if(used[i])  {
			continue
		}

		// do
		choiceList = append(choiceList,path[i])
		used[i] = true
		//recursion
		permute_(path,choiceList,used)

		//backdo
		choiceList = choiceList[:len(choiceList)-1]
		used[i] = false
	}
}
```




## 双指针
> 1. 死循环, 2. 虚拟头节点

```go

func Test21(t *testing.T) {

	var l1 = &ListNode{
		1, &ListNode{2, &ListNode{4, nil}},
	}

	var l2 = &ListNode{
		1, &ListNode{3, &ListNode{4, nil}},
	}

	fmt.Printf("%v", mergeTwoLists(l1, l2))
}

type ListNode struct {
	Val  int
	Next *ListNode
}

func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
	var dummy = &ListNode{
		-1, nil,
	}
	p := dummy
	pointA := list1
	pointB := list2

	for pointA != nil && pointB != nil {
		// 比较
		if pointA.Val > pointB.Val {
			p.Next = pointB
			pointB = pointB.Next
		} else {
			p.Next = pointA
			pointA = pointA.Next
		}

		p = p.Next
	}

	if pointA != nil {
		p.Next = pointA
	}

	if pointB != nil {
		p.Next = pointB
	}

	return dummy.Next
}

```

## 快慢指针


## 前缀和
> 数组的预处理, 第0项到当前项的和=nums[i]+ preSum[i]
> 空间换时间
> 适用场景: 原始数组不会被修改的情况下, 频繁查询某个区域的累加和

```go

func TestMatrix(t *testing.T) {
	matrix := [][]int{
		{3, 0, 1, 4, 2}, {5, 6, 3, 2, 1}, {1, 2, 0, 1, 5}, {4, 1, 0, 1, 7}, {1, 0, 3, 0, 5},
	}

	limits := [][]int{
		{2, 1, 4, 3}, {1, 1, 2, 2}, {1, 2, 2, 4},
	}
	obj := Constructor2(matrix)
	for i := 0; i < len(limits); i++ {
		limit := limits[i]
		fmt.Printf("%v \n", obj.SumRegion(limit[0], limit[1], limit[2], limit[3]))
	}
}

type NumMatrix struct {
	preSum [][]int
}

func Constructor2(matrix [][]int) NumMatrix {
	a := NumMatrix{
		preSum: make([][]int, len(matrix)+1),
	}

	for i := 0; i < len(a.preSum); i++ {
		a.preSum[i] = make([]int, len(matrix[0])+1)
	}

	// 6*6?

	// 遍历6次

	for i := 0; i < len(matrix); i++ {
		fmt.Printf("%v\n", matrix[i])
	}

	fmt.Printf("== == == == = \n")

	for i := 1; i <= len(matrix); i++ {
		for j := 1; j <= len(matrix[0]); j++ {
			//  计算和 [0][0],i,j的元素和
			aa := a.preSum[i-1][j]
			bb := a.preSum[i][j-1]
			cc := matrix[i-1][j-1]
			dd := a.preSum[i-1][j-1]
			a.preSum[i][j] = aa + bb + cc - dd
		}
	}

	for i := 0; i < len(a.preSum); i++ {
		fmt.Printf("%v\n", a.preSum[i])
	}

	return a
}

func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {
	//  目标矩阵之和由四个相邻矩阵运算获得

	aa := this.preSum[row2+1][col2+1]
	bb := this.preSum[row1][col2+1]
	cc := this.preSum[row2+1][col1]
	dd := this.preSum[row1][col1]
	return aa - bb - cc + dd
}

```

## 差分

> 数据的预处理,
> 适用场景: 频繁对原始数组的某个区间元素进行修改

```go

func Test1109(t *testing.T) {
	bookings := [][]int{
		{1, 2, 10}, {2, 3, 20}, {2, 5, 25},
	}

	fmt.Println(corpFlightBookings(bookings, 5))
}

func corpFlightBookings(bookings [][]int, n int) []int {
	//
	res := make([]int, n)
	obj := Cont(res)

	for _, booking := range bookings {
		i := booking[0] - 1
		j := booking[1] - 1
		val := booking[2]

		obj.increment(i, j, val)
	}
	return obj.result()
}

type Difference struct {
	diff []int
}


func Cont(nums []int) *Difference {
	a := &Difference{
		diff: make([]int, len(nums)),
	}
	if len(nums) == 0 {
		return a
	}

	a.diff[0] = nums[0]

	for i := 1; i < len(nums); i++ {
		a.diff[i] = nums[i] - nums[i-1]
	}

	return a

}

func (d *Difference) increment(i, j, val int) {
	// 第一个直接赋值 diff[0] = nums[0]
	// diff[i] = nums[i] =nums[i-1]

	d.diff[i] += val
	if j+1 < len(d.diff) {
		d.diff[j+1] -= val
	}
}

func (d *Difference) result() []int {
	res := make([]int, len(d.diff))
	// 根据差分数据构造结果数组
	// 反推 [0] 直接处理
	// res[i] = res[i-1] + diff[i]
	res[0] = d.diff[0]
	for i := 1; i < len(d.diff); i++ {
		res[i] = res[i-1] + d.diff[i]
	}

	return res
}

```

## 二维数组花式
### 旋转


[48.旋转图像](https://leetcode.cn/problems/rotate-image/)

思路: 正方形旋转-> 先斜线反转 接着反转当前行

```go
func rotate(matrix [][]int)  {
    // 斜着遍历
    for i:=0; i<len(matrix); i++ {
        for j:=i; j< len(matrix); j++ {
            tmp := matrix[i][j]
            matrix[i][j] = matrix[j][i]
            matrix[j][i] = tmp
        }
    }


    // 原地反转一行
    for i:=0; i<len(matrix); i++ {
        reverse(matrix[i])
    }
}

func reverse(row []int){
   i, j:= 0, len(row)-1

   for j > i {
       tmp := row[i]
       row[i] = row[j]
       row[j] = tmp

       j--
       i++
   }
}
```

## 二分搜索

[704.二分查找](https://leetcode.cn/problems/binary-search/)
```go
func search(nums []int, target int) int {
  left, right := 0, len(nums)-1
  if len(nums) == 0 {
      return -1
  }

  for left <= right {
      mid := left + (right - left) / 2
      if nums[mid] == target {
          return mid
      } else if nums[mid] < target {
          left = mid + 1
      } else if nums[mid] > target {
          right = mid - 1
      }
  }

  return -1
}

```
## 滑动窗口

[76.最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

```go
func minWindow(s string, t string) string {
    var cs, ct = make(map[byte]int), make(map[byte]int)
    for i := range t {
        ct[t[i]] ++
    }
    check := func()bool{
        for k, v := range ct{
            if cs[k] < v{
                return false
            }
        }
        return true
    }
    var resL, minLen = -1, math.MaxInt32
    for i,j := 0,0; j < len(s); j++{
        if ct[s[j]] > 0{
            cs[s[j]]++
        }
        for check() && i <= j{
            if j - i + 1 < minLen{
                minLen = j - i + 1
                resL = i
            }
            if cs[s[i]] > 0 {
                cs[s[i]]--
            }
            i++
        }
    }
    if resL == -1{
        return ""
    }
    return s[resL: resL + minLen]
}

```



## 递归反转链表

[92.反转链表2](https://leetcode.cn/problems/reverse-linked-list-ii/)

```go
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    if left ==1 {
        return reverseN(head, right)
    }

    head.Next = reverseBetween(head.Next, left -1, right -1)

    return head
}


var success *ListNode
func reverseN(head *ListNode, n int) *ListNode {
    if n== 1{
        success = head.Next
        return head
    }

    last := reverseN(head.Next, n-1)

    head.Next.Next = head
    head.Next = success

    return last
}
```


## LRU 算法

[146.LRU缓存](https://leetcode.cn/problems/lru-cache/)
```go
type LRUCache struct {
	lruMap map[int]*Node
	cache  *DoubleList
	cap    int
}


func Constructor(capacity int) LRUCache {
	res := &LRUCache{
		cap:    capacity,
		lruMap: make(map[int]*Node),
		cache:  ConstructorDoubleList(),
	}

	return *res
}


func (this *LRUCache) Get(key int) int {
	if _, ok := this.lruMap[key]; !ok {
		return -1
	}
	this.makeRecently(key)
	return this.lruMap[key].val
}

func (this *LRUCache) Put(key int, value int) {
	if _, ok := this.lruMap[key]; ok {
		this.deleteKey(key)
		this.addRecently(key, value)
		return
	}

	if this.cap == this.cache.ListSize() {
		this.removeLeastRecently()
	}

	this.addRecently(key, value)
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */

func (this *LRUCache) makeRecently(key int) {
	node := this.lruMap[key]
	this.cache.remove(node)
	this.cache.addLast(node)
}

func (this *LRUCache) addRecently(key, val int) {
	node := ConstructorNode(key, val)
	this.cache.addLast(node)
	this.lruMap[key] = node
}

func (this *LRUCache) deleteKey(key int) {
	node := this.lruMap[key]
	this.cache.remove(node)
	delete(this.lruMap, key)
}

func (this *LRUCache) removeLeastRecently() {
	first := this.cache.removeFirst()
	key := first.key
	delete(this.lruMap, key)
}


type Node struct {
	key  int
	val  int
	prev *Node
	next *Node
}

func ConstructorNode(k, v int) *Node {

	res := &Node{
		key: k,
		val: v,
	}

	return res
}

type DoubleList struct {
	head *Node
	tail *Node
	size int
}

func ConstructorDoubleList() *DoubleList {

	head := ConstructorNode(0, 0)
	tail := ConstructorNode(0, 0)
	head.next = tail
	tail.prev = head
	res := &DoubleList{
		head: head,
		tail: tail,
		size: 0,
	}

	return res
}

//
func (d *DoubleList) addLast(node *Node) {
	node.prev = d.tail.prev
	node.next = d.tail
	d.tail.prev.next = node
	d.tail.prev = node
	d.size++
}

func (d *DoubleList) remove(node *Node) {
	node.prev.next = node.next
	node.next.prev = node.prev
	d.size--
}

func (d *DoubleList) removeFirst() *Node {
	if d.head.next == d.tail {
		return nil
	}

	first := d.head.next
	d.remove(first)
	return first
}

func (d *DoubleList) ListSize() int {
	return d.size
}

```

## 数组中以O(1) 删除元素

[380.o1时间插入, 删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

动态数组和map做索引

list get 尾部插入o1
```go
type RandomizedSet struct {
    nums []int
    valtoIndex map[int]int
}


func Constructor() RandomizedSet {
    return RandomizedSet{[]int{},map[int]int{}}
}


func (this *RandomizedSet) Insert(val int) bool {
    if _, ok := this.valtoIndex[val]; !ok {
        // 尾部插入, 记录索引
        this.valtoIndex[val] = len(this.nums)
        this.nums = append(this.nums,val)
        return true
    }

    return false
}


func (this *RandomizedSet) Remove(val int) bool {
	if _, ok := this.valtoIndex[val]; ok {
		// 找到索引
		idx := this.valtoIndex[val]
		// 改最后一个索引
		lastNum := this.nums[len(this.nums)-1]
		this.valtoIndex[lastNum] = idx
		// 删除索引
		delete(this.valtoIndex, val)
		// 交换位置
		tmp := this.nums[idx]
		this.nums[idx] = lastNum
		lastNum = tmp
		// 删除最后一个
		this.nums = this.nums[:len(this.nums)-1]
		return true
	}

	return false
}


func (this *RandomizedSet) GetRandom() int {
	if len(this.nums) == 0 {
		return -1
	}
	index := rand.Intn(len(this.nums))
	return this.nums[index]
}


/**
 * Your RandomizedSet object will be instantiated and called as such:
 * obj := Constructor();
 * param_1 := obj.Insert(val);
 * param_2 := obj.Remove(val);
 * param_3 := obj.GetRandom();
 */

 ```



## 单调队列设计
> 队列中的元素全都是单调递增(递减)的, 保持先进先出的时间顺序

[239.滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

```go
func maxSlidingWindow(nums []int, k int) []int {
    queue := MonntonicQueue{}
    res := []int{}

    for i:=0; i<len(nums); i++ {
        if i< k-1 {
            queue.push(nums[i])
        } else {
            queue.push(nums[i])

            res = append(res, queue.max())

            n := nums[i-k+1]
            if n == queue.max(){
                queue.pop()
            }
        }
    }


    return res
}


type MonntonicQueue struct {
    maxq []int
}


func (q *MonntonicQueue) push(n int) {
    for len(q.maxq) >0 && q.maxq[len(q.maxq)-1:][0]< n {
        q.maxq = q.maxq[:len(q.maxq)-1]
    }
    q.maxq = append(q.maxq,n)
}


func (q *MonntonicQueue) max() int {
	return q.maxq[0:1][0]
}

func (q *MonntonicQueue) min() int {
	return q.maxq[len(q.maxq)-1:][0]
}

func (q *MonntonicQueue) pop() {
	q.maxq = q.maxq[1:]
}

```




## 二叉树

快排是二叉树的前序遍历, 归并就是二叉树的后序遍历

1. 遍历一遍二叉树得出答案 > 回溯
2. 通过分解问题计算出答案 > 动态规划

```
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
}

```


[104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

```go

/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }

    leftDepth :=  maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)

    res := math.Max(float64(leftDepth),float64(rightDepth))
    return int(res) + 1
    // res = 0
    // dfs(root)
    // return res
}


var res int
var depth int
func dfs (root *TreeNode) {
    if root == nil {
        return
    }

    depth ++
    if root.Left == nil && root.Right == nil {
        res = int(math.Max(float64(res), float64(depth)))
    }

    dfs(root.Left)
    dfs(root.Right)
    depth --
}

```



##  BST (二叉搜索树)
具有左小右大的特性, 做类似二分搜索的操作

[700.二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)
[98.验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

<!-- tabs:start -->

#### 98

```go

func isValidBST(root *TreeNode) bool {
    return isValidBST2(root,nil,nil)
}


func isValidBST2(root, min, max  *TreeNode) bool {
    if root == nil {
        return true
    }

    if min != nil && root.Val <= min.Val {
        return false
    }

    if max != nil && root.Val >= max.Val {
        return false
    }

    return isValidBST2(root.Left,min, root) && isValidBST2(root.Right,root,max)

}
```

#### 700

```go

func searchBST(root *TreeNode, val int) *TreeNode {
    if root == nil {
        return nil
    }

    if root.Val < val {
        return searchBST(root.Right, val)
    }

    if root.Val > val {
        return searchBST(root.Left, val)
    }

    return root
}

```

<!-- tabs:end -->




<!-- tabs:start -->

#### **English**

Hello!

#### **French**

Bonjour!

#### **Italian**

Ciao!

<!-- tabs:end -->

