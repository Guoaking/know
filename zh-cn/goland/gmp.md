```
轮询调度
CPU利用率 , 切换成本, 高内存

用户线程(co-routing)绑定内核线程(thread)
多个协程通过 协程调度器 来绑定内核线程  (cpu不需要切换)  N:1
协程调度器管理多个内核线程   M:N
gorouting (几KB)
大小: 几KB
灵活调度

早期
全局协程队列
1. 创建, 销毁, 调度G都需要每个M获取锁, 形成了激烈的锁竞争
2. M转移G会造成延迟和额外的系统负载
3. 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作, 增加了系统开销


now
G:goroutine
P: processor 处理器 gomaxprocs, 程序启动时创建
M:thread线程: 当前操作分配给go程序的内核线程数

全局队列:存放等待运行的G
P本地队列: 当前P等待执行的G 不超过256G, 优先放在本地P, 满了放全局队列

策略
复用线程:
work stealing机制:(偷取) m1忙, m2空间, 偷m1的g
hand off机制:(分离) g阻塞, g1和m1绑定, p和m3绑定
避免创建销毁线程
利用并行: gomaxprocs 限制占用的cpu
抢占: co-routine: c要主动释放cpu 不然c2 永远等待
goroutine: g 10ms 不释放, g2 抢占cpu 防止g2饿死
全局G队列: work stealing: 其他本地队列没有就去全局队列

gofunc 过程:


调度器的生命周期:
MO: 启动程序后编号为0的主线程 在全局变量, 不在heap上分配, 初始化第一个G
G0:启动一个M, 第一个创建的goroutine , 用于调度其他的G, 不指向任何可执行的函数, 每个M都有自己的G0, 在调度或系统调用时会时候M会切换到G0来调度, M0的G0会放在全局空间
```
